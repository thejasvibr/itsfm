

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>measure_horseshoe_bat_calls.segment_horseshoebat_call &mdash; measure horseshoe bat calls 1.0.0 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/gallery.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/gallery-binder.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/gallery-dataframe.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> measure horseshoe bat calls
          

          
            
            <img src="../../_static/measure_CF_calls_logo_v1.0.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../gallery_dir/plot_segmenting_real_sounds.html">Analysing real recordings</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../gallery_dir/plot_peak_percentage.html">The peak-percentage method</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../gallery_dir/plot_peak_percentage.html#how-does-it-work">How does it work?</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../gallery_dir/plot_peak_percentage.html#references">References</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../gallery_dir/plot_choosing_correct_max_acc.html">Setting the correct <cite>max_acc</cite> value</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../gallery_dir/plot_choosing_correct_max_acc.html#an-example-frequency-profile">An example frequency profile</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../gallery_dir/plot_pwvd.html">Segmenting CF and FM using the PWVD method</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../gallery_dir/plot_pwvd.html#how-does-it-work">How does it work?</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../gallery_dir/plot_pwvd.html#references">References</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../gallery_dir/plot_segmenting_accurately.html">Segmenting real-world sounds correctly with synthetic sounds</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../gallery_dir/plot_segmenting_accurately.html#synthetic-calls-to-the-rescue">Synthetic calls to the rescue</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../gallery_dir/plot_segmenting_accurately.html#generating-a-classical-cf-fm-bat-call">Generating a ‘classical’ CF-FM bat call</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../gallery_dir/plot_segmenting_accurately.html#a-multi-component-bird-call">A multi-component bird call</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../gallery_dir/plot_segmenting_accurately.html#let-there-be-noise">Let there be Noise</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../gallery_dir/plot_custom_measurements.html">Inbuilt and custom measurements on CF and FM segments</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">measure horseshoe bat calls</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>measure_horseshoe_bat_calls.segment_horseshoebat_call</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for measure_horseshoe_bat_calls.segment_horseshoebat_call</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;Module that segments the horseshoebat call into FM and CF parts</span>
<span class="sd">The primary logic of this </span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
<span class="kn">import</span> <span class="nn">pywt</span>
<span class="kn">import</span> <span class="nn">scipy.interpolate</span> <span class="k">as</span> <span class="nn">interpolate</span> 
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">ndimage</span>
<span class="kn">import</span> <span class="nn">scipy.ndimage.filters</span> <span class="k">as</span> <span class="nn">flts</span>
<span class="kn">import</span> <span class="nn">scipy.signal</span> <span class="k">as</span> <span class="nn">signal</span> 
<span class="kn">from</span> <span class="nn">measure_horseshoe_bat_calls.signal_processing</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">measure_horseshoe_bat_calls.sanity_checks</span> <span class="kn">import</span> <span class="n">make_sure_its_positive</span>
<span class="kn">from</span> <span class="nn">measure_horseshoe_bat_calls.frequency_tracking</span> <span class="kn">import</span> <span class="n">get_pwvd_frequency_profile</span>
<span class="kn">import</span> <span class="nn">measure_horseshoe_bat_calls.refine_cfm_regions</span> <span class="k">as</span> <span class="nn">refine_cfm</span>
<span class="kn">from</span> <span class="nn">measure_horseshoe_bat_calls.signal_cleaning</span> <span class="kn">import</span> <span class="n">suppress_background_noise</span>

<div class="viewcode-block" id="segment_call_into_cf_fm"><a class="viewcode-back" href="../../index.html#measure_horseshoe_bat_calls.segment_horseshoebat_call.segment_call_into_cf_fm">[docs]</a><span class="k">def</span> <span class="nf">segment_call_into_cf_fm</span><span class="p">(</span><span class="n">call</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Function which identifies regions into CF and FM based on the following   process. </span>

<span class="sd">    1. Candidate regions of CF and FM are first produced based on the segmentation</span>
<span class="sd">    method chosen&#39;.</span>

<span class="sd">    2. These candidate regions are then refined based on the </span>
<span class="sd">    user&#39;s requirements (minimum length of region, maximum number of CF/FM</span>
<span class="sd">    regions in the sound)</span>

<span class="sd">    3. The finalised CF and FM regions are output as Boolean arrays.</span>

<span class="sd">    Parameters</span>
<span class="sd">    -----------</span>
<span class="sd">    call : np.array</span>
<span class="sd">        Audio with horseshoe bat call</span>
<span class="sd">    fs : float&gt;0</span>
<span class="sd">        Frequency of sampling in Hz. </span>
<span class="sd">    segment_method : str, optional </span>
<span class="sd">        One of [&#39;peak_percentage&#39;, &#39;pwvd&#39;, &#39;inst_freq&#39;].</span>
<span class="sd">        Checkout &#39;See Also&#39; for more information. </span>
<span class="sd">        Defaults to &#39;peak_percentage&#39;</span>
<span class="sd">    refinement_method : function, str, optional</span>
<span class="sd">        The method used to refine the initial CF and FM</span>
<span class="sd">        candidate regions according to the different constraints</span>
<span class="sd">        and rules set by the user. </span>
<span class="sd">        </span>
<span class="sd">        Defaults to &#39;do_nothing&#39;</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    cf_samples, fm_samples : np.array</span>
<span class="sd">        Boolean numpy array showing which of the samples belong </span>
<span class="sd">        to the cf and the fm respectively. </span>

<span class="sd">    info : dictionary</span>
<span class="sd">        Post-processing information depending on </span>
<span class="sd">        the methods used. </span>


<span class="sd">    See Also</span>
<span class="sd">    ----------</span>
<span class="sd">    segment_by_peak_percentage</span>
<span class="sd">    segment_by_pwvd</span>
<span class="sd">    segment_by_inst_frequency</span>
<span class="sd">    measure_horseshoe_bat_calls.refine_cfm_regions </span>
<span class="sd">    refine_cf_fm_candidates</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The post-processing information in the object `info` depends on the method </span>
<span class="sd">    used. </span>
<span class="sd">    </span>
<span class="sd">    peak_percentage : the two keys &#39;fm_re_cf&#39; and &#39;cf_re_fm&#39; which are the </span>
<span class="sd">        relative dBrms profiles of FM with relation to the CF portion and vice versa</span>
<span class="sd">    </span>
<span class="sd">    pwvd : </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">segment_method</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;segment_method&#39;</span><span class="p">,</span> <span class="s1">&#39;peak_percentage&#39;</span><span class="p">)</span>
    <span class="n">refinement_method</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;refinement_method&#39;</span><span class="p">,</span> <span class="s1">&#39;do_nothing&#39;</span><span class="p">)</span>
    <span class="c1"># identify candidate CF and FM regions </span>
    <span class="n">cf_candidates</span><span class="p">,</span> <span class="n">fm_candidates</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">perform_segmentation</span><span class="p">[</span><span class="n">segment_method</span><span class="p">](</span><span class="n">call</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span>
                                                                 <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="n">cf</span><span class="p">,</span> <span class="n">fm</span> <span class="o">=</span> <span class="n">refine_cf_fm_candidates</span><span class="p">(</span><span class="n">refinement_method</span><span class="p">,</span>
                                     <span class="p">[</span><span class="n">cf_candidates</span><span class="p">,</span> <span class="n">fm_candidates</span><span class="p">],</span>
                                     <span class="n">fs</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">cf</span><span class="p">,</span> <span class="n">fm</span><span class="p">,</span> <span class="n">info</span></div>

<div class="viewcode-block" id="refine_cf_fm_candidates"><a class="viewcode-back" href="../../index.html#measure_horseshoe_bat_calls.segment_horseshoebat_call.refine_cf_fm_candidates">[docs]</a><span class="k">def</span> <span class="nf">refine_cf_fm_candidates</span><span class="p">(</span><span class="n">refinement_method</span><span class="p">,</span> <span class="n">cf_fm_candidates</span><span class="p">,</span>
                            <span class="n">fs</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> 
                            <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Parses the refinement method, checks if its string or function</span>
<span class="sd">    and calls the relevant objects. </span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    refinement_method : str/function </span>
<span class="sd">        A string from the list of inbuilt functions in the module</span>
<span class="sd">        `refine_cfm_regions` or a user-defined function. </span>
<span class="sd">        Defaults to `do_nothing`, an inbuilt function which</span>
<span class="sd">        doesn&#39;t returns the candidate Cf-fm regions without </span>
<span class="sd">        alteration. </span>
<span class="sd">    cf_fm_candidates : list with 2 np.arrays</span>
<span class="sd">        Both np.arrays need to be Boolean and of the same size as the original</span>
<span class="sd">        audio. </span>
<span class="sd">    fs : float&gt;0</span>
<span class="sd">    info : dictionary</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    cf, fm : np.array</span>
<span class="sd">        Boolean arrays wher True indicates the sample is of the corresponding</span>
<span class="sd">        region. </span>

<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">refinement_method</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">refinement_function</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">refine_cfm</span><span class="p">,</span> <span class="n">refinement_method</span><span class="p">)</span>
        <span class="n">cf_samples</span><span class="p">,</span> <span class="n">fm_samples</span> <span class="o">=</span> <span class="n">refinement_function</span><span class="p">(</span><span class="n">cf_fm_candidates</span><span class="p">,</span>
                                                     <span class="n">fs</span><span class="p">,</span>
                                                     <span class="n">info</span><span class="p">,</span> 
                                                     <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">callable</span><span class="p">(</span><span class="n">refinement_method</span><span class="p">):</span>
        <span class="c1"># could cause issues with inbuilt functions apparently?</span>
        <span class="n">cf_samples</span><span class="p">,</span> <span class="n">fm_samples</span> <span class="o">=</span> <span class="n">refinement_method</span><span class="p">(</span><span class="n">cf_fm_candidates</span><span class="p">,</span>
                                                         <span class="n">fs</span><span class="p">,</span>
                                                         <span class="n">info</span><span class="p">,</span> 
                                                         <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unable to parse refinement method -  please check input:&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">cf_samples</span><span class="p">,</span> <span class="n">fm_samples</span></div>

<div class="viewcode-block" id="segment_by_peak_percentage"><a class="viewcode-back" href="../../index.html#measure_horseshoe_bat_calls.segment_horseshoebat_call.segment_by_peak_percentage">[docs]</a><span class="k">def</span> <span class="nf">segment_by_peak_percentage</span><span class="p">(</span><span class="n">call</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;This is ideal for calls with one clear CF section with the CF </span>
<span class="sd">    portion being the highest frequency in the call: bat/bird CF-FM</span>
<span class="sd">    calls which have on CF and one/two sweep section.</span>

<span class="sd">    Calculates the peak frequency of the whole call and performs </span>
<span class="sd">    low+high pass filtering at a frequency slightly lower than the peak frequency. </span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    call : np.array</span>
<span class="sd">    fs : float&gt;0</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    cf_samples, fm_samples : np.array</span>
<span class="sd">        Boolean array with True indicating that sample has been categorised</span>
<span class="sd">        as being CF and/or FM. </span>
<span class="sd">    info : dictionary</span>
<span class="sd">        With keys &#39;fm_re_cf&#39; and &#39;cf_re_fm&#39; indicating the relative </span>
<span class="sd">        dBrms profiles of the candidate FM regions relative to Cf </span>
<span class="sd">        and vice versa.</span>
<span class="sd">    </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This method unsuited for audio with non-uniform call envelopes. </span>
<span class="sd">    When there is high variation over the call envelope, the peak frequency </span>
<span class="sd">    is likely to be miscalculated, and thus lead to wrong segmentation.</span>

<span class="sd">    This method is somewhat inspired by the protocol in Schoeppler et al. 2018. </span>
<span class="sd">    However, it differs in the important aspect of being done entirely in the </span>
<span class="sd">    time domain. Schoeppler et al. 2018 use a spectrogram based method </span>
<span class="sd">    to segment the CF and FM segments of H. armiger calls. </span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    [1] Schoeppler, D., Schnitzler, H. U., &amp; Denzinger, A. (2018). </span>
<span class="sd">    Precise Doppler shift compensation in the hipposiderid bat, </span>
<span class="sd">    Hipposideros armiger. Scientific Reports, 8(1), 1-11.     </span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    pre_process_for_segmentation</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">cf_dbrms</span><span class="p">,</span> <span class="n">fm_dbrms</span> <span class="o">=</span> <span class="n">pre_process_for_segmentation</span><span class="p">(</span><span class="n">call</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">fm_re_cf</span> <span class="o">=</span> <span class="n">fm_dbrms</span> <span class="o">-</span> <span class="n">cf_dbrms</span>
    <span class="n">cf_re_fm</span> <span class="o">=</span> <span class="n">cf_dbrms</span> <span class="o">-</span> <span class="n">fm_dbrms</span>
    
    <span class="n">fm_samples</span> <span class="o">=</span> <span class="n">fm_re_cf</span> <span class="o">&gt;</span> <span class="mi">0</span> 
    <span class="n">cf_samples</span> <span class="o">=</span> <span class="n">cf_re_fm</span> <span class="o">&gt;</span> <span class="mi">0</span>

    <span class="n">fm_samples</span> <span class="o">=</span> <span class="n">suppress_background_noise</span><span class="p">(</span><span class="n">fm_samples</span><span class="p">,</span> <span class="n">call</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">cf_samples</span> <span class="o">=</span> <span class="n">suppress_background_noise</span><span class="p">(</span><span class="n">cf_samples</span><span class="p">,</span> <span class="n">call</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="n">info</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;fm_re_cf&#39;</span><span class="p">:</span> <span class="n">fm_re_cf</span><span class="p">,</span>
            <span class="s1">&#39;cf_re_fm&#39;</span><span class="p">:</span><span class="n">cf_re_fm</span><span class="p">,</span>
            <span class="s1">&#39;cf_dbrms&#39;</span><span class="p">:</span><span class="n">cf_dbrms</span><span class="p">,</span>
            <span class="s1">&#39;fm_dbrms&#39;</span><span class="p">:</span><span class="n">fm_dbrms</span><span class="p">}</span>

    <span class="k">return</span> <span class="n">cf_samples</span><span class="p">,</span> <span class="n">fm_samples</span><span class="p">,</span> <span class="n">info</span> </div>


<div class="viewcode-block" id="segment_by_pwvd"><a class="viewcode-back" href="../../index.html#measure_horseshoe_bat_calls.segment_horseshoebat_call.segment_by_pwvd">[docs]</a><span class="k">def</span> <span class="nf">segment_by_pwvd</span><span class="p">(</span><span class="n">call</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;This method is technically more accurate in segmenting CF and FM portions</span>
<span class="sd">    of a sound. The Pseudo-Wigner-Ville Distribution of the input signal </span>
<span class="sd">    is generated. </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    call : np.array</span>
<span class="sd">    fs : float&gt;0</span>
<span class="sd">    fmrate_threshold : float &gt;=0</span>
<span class="sd">        The threshold rate of frequency modulation in kHz/ms. Beyond this value a segment</span>
<span class="sd">        of audio is considered a frequency modulated region. </span>
<span class="sd">        Defaults to 0.2 kHz/ms</span>

<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    cf_samples, fm_samples : np.array</span>
<span class="sd">        Boolean array of same size as call indicating candidate CF and FM regions. </span>
<span class="sd">    </span>
<span class="sd">    info : dictionary</span>
<span class="sd">        See get_pwvd_frequency_profile for the keys it outputs in the `info` </span>
<span class="sd">        dictioanry. In addition, another key &#39;fmrate&#39; is also calculated</span>
<span class="sd">        which has an np. array with the rate of frequency modulation across</span>
<span class="sd">        the signal in kHz/ms.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This method may takes some time to run. It is computationally intensive. </span>
<span class="sd">    This method may not work very well in the presence of multiple harmonics</span>
<span class="sd">    or noise. Some basic tweaking of the optional parameters may be required. </span>

<span class="sd">    </span>
<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    get_pwvd_frequency_profile</span>
<span class="sd">    </span>
<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    Let&#39;s create a two component call with a CF and an FM part in it </span>
<span class="sd">    &gt;&gt;&gt; from measure_horseshoe_bat_calls.simulate_calls import make_tone, make_fm_chirp, silence</span>
<span class="sd">    &gt;&gt;&gt; fs = 22100</span>
<span class="sd">    &gt;&gt;&gt; tone = make_tone(5000, 0.01, fs)</span>
<span class="sd">    &gt;&gt;&gt; sweep = make_fm_chirp(1000, 6000, 0.005, fs)</span>
<span class="sd">    &gt;&gt;&gt; gap = silence(0.005, fs)</span>
<span class="sd">    &gt;&gt;&gt; full_call = np.concatenate((tone, gap, sweep))</span>
<span class="sd">    &gt;&gt;&gt; # reduce rms calculation window size because of low sampling rate!</span>
<span class="sd">    &gt;&gt;&gt; cf, fm, info = segment_by_pwvd(full_call, </span>
<span class="sd">                                           fs,</span>
<span class="sd">                                            window_size=50,</span>
<span class="sd">                                            background_noise=-40,</span>
<span class="sd">                                            sample_every=0.1*10**-3)</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">fmrate_threshold</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;fmrate_threshold&#39;</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">)</span> <span class="c1"># kHz/ms</span>

    <span class="n">clean_frequency_profile</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">get_pwvd_frequency_profile</span><span class="p">(</span><span class="n">call</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="n">fmrate</span><span class="p">,</span> <span class="n">fitted_freq_profile</span> <span class="o">=</span> <span class="n">whole_audio_fmrate</span><span class="p">(</span><span class="n">clean_frequency_profile</span><span class="p">,</span> 
                                                         <span class="n">fs</span><span class="p">,</span> 
                                                         <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="n">info</span><span class="p">[</span><span class="s1">&#39;fmrate&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fmrate</span>
    <span class="n">info</span><span class="p">[</span><span class="s1">&#39;cleaned_fp&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">clean_frequency_profile</span>
    <span class="n">info</span><span class="p">[</span><span class="s1">&#39;fitted_fp&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fitted_freq_profile</span>

    <span class="n">fm_samples</span> <span class="o">=</span> <span class="n">fmrate</span> <span class="o">&gt;</span> <span class="n">fmrate_threshold</span>
    <span class="n">cf_samples</span> <span class="o">=</span> <span class="n">fmrate</span> <span class="o">&lt;=</span> <span class="n">fmrate_threshold</span>

    <span class="n">fm_samples</span> <span class="o">=</span> <span class="n">suppress_background_noise</span><span class="p">(</span><span class="n">fm_samples</span><span class="p">,</span> <span class="n">call</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">cf_samples</span> <span class="o">=</span> <span class="n">suppress_background_noise</span><span class="p">(</span><span class="n">cf_samples</span><span class="p">,</span> <span class="n">call</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">cf_samples</span><span class="p">,</span> <span class="n">fm_samples</span><span class="p">,</span> <span class="n">info</span></div>

<div class="viewcode-block" id="whole_audio_fmrate"><a class="viewcode-back" href="../../index.html#measure_horseshoe_bat_calls.segment_horseshoebat_call.whole_audio_fmrate">[docs]</a><span class="k">def</span> <span class="nf">whole_audio_fmrate</span><span class="p">(</span><span class="n">whole_freq_profile</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    When a recording has multiple components to it, there are silences</span>
<span class="sd">    in between. These silences/background noise portions are assigned</span>
<span class="sd">    a value of 0 Hz. </span>
<span class="sd">    </span>
<span class="sd">    When a &#39;whole audio&#39; fm rate is naively calculated by taking the diff</span>
<span class="sd">    of the whole frequency profile, there will be sudden jumps in the fm-rate</span>
<span class="sd">    due to the silent parts with 0Hz and the sound segments with non-zero </span>
<span class="sd">    segments. Despite these spikes being very short, they then propagate their</span>
<span class="sd">    influence due to the median filtering that is later down downstream. This</span>
<span class="sd">    essentially causes an increase of false positive FM segments because of the</span>
<span class="sd">    apparent high fmrate. </span>
<span class="sd">    </span>
<span class="sd">    To overcome the issues caused by the sudden zero to non-zero transitions </span>
<span class="sd">    in frequency values, this function handles each non-zero sound segment</span>
<span class="sd">    separately, and calculates the fmrate over each sound segment independently.</span>

<span class="sd">    Parameters</span>
<span class="sd">    -----------</span>
<span class="sd">    whole_freq_profile : np.array</span>
<span class="sd">        Array with sample-level frequency values of the same size as the </span>
<span class="sd">        audio. </span>
<span class="sd">    fs : float&gt;0</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    fmrate : np.array</span>
<span class="sd">        The rate of frequency modulation in kHz/ms. Same size as `whole_freq_profile`</span>
<span class="sd">        Regions in `whole_freq_profile` with 0 frequency are set to 0kHz/ms.</span>
<span class="sd">    fitted_frequency_profile : np.aray</span>
<span class="sd">        The downsampled, smoothed version of `whole_freq_profile`, of the same size. </span>
<span class="sd">    </span>
<span class="sd">    Attention</span>
<span class="sd">    ---------</span>
<span class="sd">    The `fmrate` *must* be processed further downstream! </span>
<span class="sd">    In the whole-audio `fmrate` array, all samples that were 0 frequency </span>
<span class="sd">    in the original `whole_freq_profile` are set to 0 kHz/ms!!!</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    calculate_fm_rate</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    Let&#39;s make a synthetic multi-component sound with 2 FMs and 1 CF component.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; fs = 22100</span>
<span class="sd">    &gt;&gt;&gt; onems = int(0.001*fs)</span>
<span class="sd">    &gt;&gt;&gt; sweep1 = np.linspace(1000,2000,onems) # fmrate of 1kHz/ms</span>
<span class="sd">    &gt;&gt;&gt; tone = np.tile(3000, 2*onems) # CF part</span>
<span class="sd">    &gt;&gt;&gt; sweep2 = np.linspace(4000,10000,3*onems) # 2kHz/ms</span>
<span class="sd">    &gt;&gt;&gt; gap = np.zeros(10)</span>
<span class="sd">    &gt;&gt;&gt; freq_profile = np.concatenate((sweep1, gap, tone, gap, sweep2))</span>
<span class="sd">    &gt;&gt;&gt; fmrate, fit_freq_profile = whole_audio_fmrate(freq_profile, fs)</span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="n">sound_segments</span><span class="p">,</span> <span class="n">num_segments</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">whole_freq_profile</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">location_segments</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">find_objects</span><span class="p">(</span><span class="n">sound_segments</span><span class="p">)</span>

    <span class="n">whole_fmrate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">whole_freq_profile</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
    <span class="n">fitted_frequency_profile</span> <span class="o">=</span> <span class="n">whole_freq_profile</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">num_segments</span> <span class="o">&lt;</span><span class="mi">1</span> <span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;No non-zero frequency segments detected!&#39;</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">location</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">location_segments</span><span class="p">):</span>
        <span class="n">segment_frequency_profile</span> <span class="o">=</span> <span class="n">whole_freq_profile</span><span class="p">[</span><span class="n">location</span><span class="p">]</span>
        <span class="n">fmrate</span><span class="p">,</span> <span class="n">fitted_freq_profile</span> <span class="o">=</span> <span class="n">calculate_fm_rate</span><span class="p">(</span><span class="n">segment_frequency_profile</span><span class="p">,</span> 
                                                                    <span class="n">fs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">whole_fmrate</span><span class="p">[</span><span class="n">location</span><span class="p">]</span> <span class="o">=</span> <span class="n">fmrate</span>
        <span class="n">fitted_frequency_profile</span><span class="p">[</span><span class="n">location</span><span class="p">]</span> <span class="o">=</span> <span class="n">fitted_freq_profile</span>
    
    <span class="k">return</span> <span class="n">whole_fmrate</span><span class="p">,</span> <span class="n">fitted_frequency_profile</span></div>
    




<span class="k">def</span> <span class="nf">segment_by_inst_frequency</span><span class="p">(</span><span class="n">call</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Plain Instant Tracking has not yet been implemented!&#39;</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span> 



<div class="viewcode-block" id="calculate_fm_rate"><a class="viewcode-back" href="../../index.html#measure_horseshoe_bat_calls.segment_horseshoebat_call.calculate_fm_rate">[docs]</a><span class="k">def</span> <span class="nf">calculate_fm_rate</span><span class="p">(</span><span class="n">frequency_profile</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;A frequency profile is generally oversampled. This means that </span>
<span class="sd">    there will be many repeated values and sometimes minor drops in </span>
<span class="sd">    frequency over time. This leads to a higher FM rate than is actually</span>
<span class="sd">    there when a sample-wise diff is performed. </span>
<span class="sd">    </span>
<span class="sd">    This method downsamples the frequency profile, fits a polynomial </span>
<span class="sd">    to it and then gets the smoothened frequency profile with unique values. </span>
<span class="sd">    </span>
<span class="sd">    The sample-level FM rate can now be calculated reliably. </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    frequency_profile : np.array</span>
<span class="sd">        Array of same size as the original audio. Each sample has </span>
<span class="sd">        the estimated instantaneous frequency in Hz. </span>
<span class="sd">    fs : float&gt;0</span>
<span class="sd">        Sampling rate in Hz</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    fm_rate : np.array</span>
<span class="sd">        Same size as frequency_profile. The rate of frequency modulation in </span>
<span class="sd">        kHz/ms</span>
<span class="sd">    </span>
<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    fit_polynomial_on_downsampled_version</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="n">medianfilter_length</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;medianfilter_length&#39;</span><span class="p">,</span> <span class="mf">0.25</span><span class="o">*</span><span class="mi">10</span><span class="o">**-</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">medianfilter_samples</span> <span class="o">=</span> <span class="n">calc_proper_kernel_size</span><span class="p">(</span><span class="n">medianfilter_length</span><span class="p">,</span> <span class="n">fs</span><span class="p">)</span>
    
    <span class="n">fitted</span> <span class="o">=</span> <span class="n">fit_polynomial_on_downsampled_version</span><span class="p">(</span><span class="n">frequency_profile</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="n">fm_rate_hz_per_sec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">fitted</span><span class="p">))</span>
    <span class="n">median_filtered</span> <span class="o">=</span> <span class="n">flts</span><span class="o">.</span><span class="n">percentile_filter</span><span class="p">(</span><span class="n">fm_rate_hz_per_sec</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> 
                                             <span class="n">medianfilter_samples</span><span class="p">)</span>
    <span class="n">fm_rate</span> <span class="o">=</span><span class="mi">10</span><span class="o">**-</span><span class="mi">6</span><span class="o">*</span><span class="p">(</span><span class="n">median_filtered</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">fs</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">fm_rate</span><span class="p">,</span> <span class="n">fitted</span></div>

<div class="viewcode-block" id="fit_polynomial_on_downsampled_version"><a class="viewcode-back" href="../../index.html#measure_horseshoe_bat_calls.segment_horseshoebat_call.fit_polynomial_on_downsampled_version">[docs]</a><span class="k">def</span> <span class="nf">fit_polynomial_on_downsampled_version</span><span class="p">(</span><span class="n">frequency_profile</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">sample_every</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;sample_every&#39;</span><span class="p">,</span> <span class="mf">0.5</span><span class="o">*</span><span class="mi">10</span><span class="o">**-</span><span class="mi">3</span><span class="p">)</span> <span class="c1">#seconds</span>
    <span class="n">interpolation_kind</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;interpolation_kind&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># polynomial order</span>
    <span class="n">ds_factor</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">fs</span><span class="o">*</span><span class="n">sample_every</span><span class="p">)</span>
    
    <span class="n">full_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">frequency_profile</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
    <span class="n">partX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">full_x</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span> <span class="n">full_x</span><span class="p">[</span><span class="mi">3</span><span class="p">::</span><span class="n">ds_factor</span><span class="p">],</span> 
                                      <span class="n">full_x</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]))</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">partX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">partX</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">partY</span> <span class="o">=</span> <span class="n">frequency_profile</span><span class="p">[</span><span class="n">partX</span><span class="p">]</span>
    
    <span class="n">fit</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="n">partX</span><span class="p">,</span> <span class="n">partY</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">interpolation_kind</span><span class="p">)</span>
    <span class="n">fitted</span> <span class="o">=</span> <span class="n">fit</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">frequency_profile</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>                           
    <span class="k">return</span> <span class="n">fitted</span> </div>
    

<div class="viewcode-block" id="refine_candidate_regions"><a class="viewcode-back" href="../../index.html#measure_horseshoe_bat_calls.segment_horseshoebat_call.refine_candidate_regions">[docs]</a><span class="k">def</span> <span class="nf">refine_candidate_regions</span><span class="p">():</span>
    <span class="sd">&#39;&#39;&#39;Takes in candidate CF and FM regions and tries to satisfy the </span>
<span class="sd">    constraints set by the user. </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">pass</span></div>


<span class="n">perform_segmentation</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;peak_percentage&#39;</span><span class="p">:</span><span class="n">segment_by_peak_percentage</span><span class="p">,</span> 
                        <span class="s1">&#39;pwvd&#39;</span><span class="p">:</span><span class="n">segment_by_pwvd</span><span class="p">,</span>
                        <span class="s1">&#39;inst_freq&#39;</span><span class="p">:</span><span class="n">segment_by_inst_frequency</span><span class="p">}</span>



<div class="viewcode-block" id="check_segment_cf_and_fm"><a class="viewcode-back" href="../../index.html#measure_horseshoe_bat_calls.segment_horseshoebat_call.check_segment_cf_and_fm">[docs]</a><span class="k">def</span> <span class="nf">check_segment_cf_and_fm</span><span class="p">(</span><span class="n">cf_samples</span><span class="p">,</span> <span class="n">fm_samples</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">main_cf</span> <span class="o">=</span> <span class="n">get_cf_region</span><span class="p">(</span><span class="n">cf_samples</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">main_fm</span> <span class="o">=</span> <span class="n">get_fm_regions</span><span class="p">(</span><span class="n">fm_samples</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">main_cf</span><span class="p">,</span> <span class="n">main_fm</span></div>


<div class="viewcode-block" id="get_cf_region"><a class="viewcode-back" href="../../index.html#measure_horseshoe_bat_calls.segment_horseshoebat_call.get_cf_region">[docs]</a><span class="k">def</span> <span class="nf">get_cf_region</span><span class="p">(</span><span class="n">cf_samples</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;TODO : generalise to multiple CF regions </span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cf_samples : np.array</span>
<span class="sd">        Boolean with True indicating a Cf region. </span>
<span class="sd">    fs : float</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    cf_region : np.array</span>
<span class="sd">        The longest continuous stretch</span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">min_cf_duration</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;min_cf_duration&#39;</span><span class="p">,</span> <span class="mf">0.001</span><span class="p">)</span>
    <span class="n">make_sure_its_positive</span><span class="p">(</span><span class="n">min_cf_duration</span><span class="p">,</span> <span class="n">variable</span><span class="o">=</span><span class="s1">&#39;min_cf_duration&#39;</span><span class="p">)</span>
    <span class="n">min_cf_samples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">fs</span><span class="o">*</span><span class="n">min_cf_duration</span><span class="p">)</span>
    <span class="n">cf_region</span> <span class="o">=</span> <span class="n">identify_valid_regions</span><span class="p">(</span><span class="n">cf_samples</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">cf_region</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">min_cf_samples</span><span class="p">:</span>
        <span class="n">msg1</span> <span class="o">=</span> <span class="s1">&#39;CF segment of minimum length (</span><span class="si">%3f</span><span class="s1">)s&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">min_cf_duration</span><span class="p">)</span>
        <span class="n">msg2</span> <span class="o">=</span> <span class="s1">&#39; could not be found&#39;</span>
        <span class="k">raise</span> <span class="n">CFIdentificationError</span><span class="p">(</span><span class="n">msg1</span><span class="o">+</span><span class="n">msg2</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">cf_region</span></div>


<div class="viewcode-block" id="get_fm_regions"><a class="viewcode-back" href="../../index.html#measure_horseshoe_bat_calls.segment_horseshoebat_call.get_fm_regions">[docs]</a><span class="k">def</span> <span class="nf">get_fm_regions</span><span class="p">(</span><span class="n">fm_samples</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;TODO : generalise to multiple FM regions</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fm_samples : np.array</span>
<span class="sd">        Boolean numpy array with candidate FM samples. </span>
<span class="sd">    fs : float&gt;0</span>
<span class="sd">    min_fm_duration : float, optional</span>
<span class="sd">        minimum fm duration expected in seconds. Any fm segment lower than this</span>
<span class="sd">        duration  is considered to be a bad read and discarded.</span>
<span class="sd">        Defaults to 0.5 milliseconds.</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    valid_fm : np.array</span>
<span class="sd">        Boolean numpy array with the corrected fm samples.</span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">min_fm_duration</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;min_fm_duration&#39;</span><span class="p">,</span> <span class="mf">0.5</span><span class="o">*</span><span class="mi">10</span><span class="o">**-</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">make_sure_its_positive</span><span class="p">(</span><span class="n">min_fm_duration</span><span class="p">,</span> <span class="n">variable</span><span class="o">=</span><span class="s1">&#39;min_fm_duration&#39;</span><span class="p">)</span>
    <span class="n">min_fm_samples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">fs</span><span class="o">*</span><span class="n">min_fm_duration</span><span class="p">)</span>

    <span class="n">valid_fm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">fm_samples</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;bool&#39;</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">main_fm</span> <span class="o">=</span> <span class="n">identify_valid_regions</span><span class="p">(</span><span class="n">fm_samples</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">regions</span><span class="p">,</span> <span class="n">region_id_and_samples</span> <span class="o">=</span> <span class="n">identify_maximum_contiguous_regions</span><span class="p">(</span><span class="n">main_fm</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">regions</span><span class="p">,</span> <span class="n">region_lengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">region_id_and_samples</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span>
                                            <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">regions_above_min_length</span> <span class="o">=</span> <span class="n">regions</span><span class="p">[</span><span class="n">region_lengths</span> <span class="o">&gt;=</span> <span class="n">min_fm_samples</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">regions_above_min_length</span><span class="p">)</span> <span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">valid_rows</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">each</span> <span class="ow">in</span> <span class="n">regions_above_min_length</span><span class="p">:</span>
                <span class="n">valid_rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">region_id_and_samples</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="n">each</span><span class="p">))</span>
            <span class="n">valid_rows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">valid_rows</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
            <span class="n">valid_samples</span> <span class="o">=</span> <span class="n">region_id_and_samples</span><span class="p">[</span><span class="n">valid_rows</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
            
            <span class="n">valid_fm</span><span class="p">[</span><span class="n">valid_samples</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">except</span><span class="p">:</span>
        <span class="n">candidate_fm</span> <span class="o">=</span> <span class="n">identify_valid_regions</span><span class="p">(</span><span class="n">fm_samples</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">candidate_fm</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">min_fm_samples</span><span class="p">:</span>
            <span class="n">valid_fm</span> <span class="o">=</span> <span class="n">candidate_fm</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
             
    <span class="k">return</span> <span class="n">valid_fm</span></div>
        

<div class="viewcode-block" id="segment_call_from_background"><a class="viewcode-back" href="../../index.html#measure_horseshoe_bat_calls.segment_horseshoebat_call.segment_call_from_background">[docs]</a><span class="k">def</span> <span class="nf">segment_call_from_background</span><span class="p">(</span><span class="n">audio</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Performs a wavelet transform to track the signal within the relevant portion of the bandwidth. </span>
<span class="sd">    </span>
<span class="sd">    This methods broadly works by summing up all the signal content </span>
<span class="sd">    above the ```lowest_relevant_frequency``` using a continuous wavelet transform. </span>
<span class="sd">    </span>
<span class="sd">    If the call-background segmentation doesn&#39;t work well it&#39;s probably due </span>
<span class="sd">    to one of these things:</span>
<span class="sd">    </span>
<span class="sd">    #. Incorrect ``background_threshold`` : Play around with different ``background_threshold values``.</span>
<span class="sd">    </span>
<span class="sd">    #. Incorrect ``lowest_relevant_frequency`` : If the lowest relevant frequency is set outside of the signal&#39;s actual frequency range, then the segmentation will fail.</span>
<span class="sd">       Try lower this parameter till you&#39;re sure all of the signal&#39;s spectral range is above it.     </span>
<span class="sd">    </span>
<span class="sd">    #. Low signal spectral range : This method uses a continuous wavelet transform to localise the relevant signal. Wavelet transforms have high temporal resolution </span>
<span class="sd">       in for high frequencies, but lower temporal resolutions for lower frequencies.</span>
<span class="sd">       If your signal is dominantly low-frequency, try resampling it to a lower </span>
<span class="sd">       sampling rate and see if this works?</span>

<span class="sd">    If the above tricks don&#39;t work, then try bandpassing your signal - may be it&#39;s</span>
<span class="sd">    an issue with the in-band signal to noise ratio.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    audio : np.array</span>
<span class="sd">    fs : float&gt;0</span>
<span class="sd">        Frequency of sampling in Hertz.</span>
<span class="sd">    lowest_relevant_freq : float&gt;0, optional</span>
<span class="sd">        The lowest frequency band in Hz whose coefficients will be tracked.</span>
<span class="sd">        The coefficients of all frequencies in the signal &gt;= the lowest relevant</span>
<span class="sd">        frequency are tracked. This is the lowest possible frequency the signal can take. It is best to give a few kHz of berth.</span>
<span class="sd">        Defaults to 35kHz.</span>
<span class="sd">    background_threshold : float&lt;0, optional</span>
<span class="sd">		The relative threshold which is used to define the background. The segmentation is </span>
<span class="sd">		performed by selecting the region that is above background_threshold dB relative</span>
<span class="sd">		to 	the max dB rms value in the audio. </span>
<span class="sd">		Defaults to -20 dB</span>
<span class="sd">    wavelet_type : str, optional</span>
<span class="sd">        The type of wavelet which will be used for the continuous wavelet transform. </span>
<span class="sd">        Run  `pywt.wavelist(kind=&#39;continuous&#39;)` for all possible types in case the default</span>
<span class="sd">        doesn&#39;t seem to work.</span>
<span class="sd">        Defaults to mexican hat, &#39;mexh&#39;</span>
<span class="sd">    scales : array-like, optional</span>
<span class="sd">        The scales to be used for the continuous wavelet transform. </span>
<span class="sd">        Defaults to np.arange(1,10).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    potential_region : np.array</span>
<span class="sd">        A boolean numpy array where True corresponds to the regions which</span>
<span class="sd">        are call samples, and False are the background samples. The single </span>
<span class="sd">        longest continuous region is output.</span>
<span class="sd">    dbrms_profile : np.array</span>
<span class="sd">        The dB rms profile of the summed up wavelet transform for all </span>
<span class="sd">        centre frequencies &gt;= lowest_relevant_frequency.s</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        When lowest_relevant_frequency is too high or not included in </span>
<span class="sd">        the centre frequencies of the default/input scales for </span>
<span class="sd">        wavelet transforms. </span>
<span class="sd">    IncorrectThreshold</span>
<span class="sd">        When the dynamic range of the relevant part of the signal is smaller</span>
<span class="sd">        or equal to the background_threshold.</span>
<span class="sd">   </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">lowest_relevant_freq</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;lowest_relevant_freq&#39;</span><span class="p">,</span> <span class="mf">35000.0</span><span class="p">)</span>
    <span class="n">make_sure_its_positive</span><span class="p">(</span><span class="n">lowest_relevant_freq</span><span class="p">,</span> <span class="n">variable</span><span class="o">=</span><span class="s1">&#39;lowest_relevant_freq&#39;</span><span class="p">)</span>
    
    <span class="n">wavelet_type</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;wavelet_type&#39;</span><span class="p">,</span> <span class="s1">&#39;mexh&#39;</span><span class="p">)</span>
    <span class="n">background_threshold</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;background_threshold&#39;</span><span class="p">,</span> <span class="o">-</span><span class="mi">20</span><span class="p">)</span>
    <span class="n">scales</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;scales&#39;</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>

    <span class="n">coefs</span><span class="p">,</span> <span class="n">freqs</span> <span class="o">=</span> <span class="n">pywt</span><span class="o">.</span><span class="n">cwt</span><span class="p">(</span><span class="n">audio</span><span class="p">,</span>
                            <span class="n">scales</span><span class="p">,</span>
                            <span class="n">wavelet_type</span><span class="p">,</span>
                            <span class="n">sampling_period</span><span class="o">=</span><span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="n">fs</span><span class="p">))</span>
    <span class="n">relevant_freqs</span> <span class="o">=</span> <span class="n">freqs</span><span class="p">[</span><span class="n">freqs</span><span class="o">&gt;=</span><span class="n">lowest_relevant_freq</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">relevant_freqs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The lowest relevant frequency is too high. Please re-check the value&#39;</span><span class="p">)</span>
    
    <span class="n">within_centre_freqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">freqs</span><span class="p">)</span><span class="o">&lt;=</span><span class="n">lowest_relevant_freq</span><span class="p">,</span>
                                         <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">freqs</span><span class="p">)</span><span class="o">&gt;=</span><span class="n">lowest_relevant_freq</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">within_centre_freqs</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The lowest relevant frequency </span><span class="si">%.2f</span><span class="s1"> is not included in the centre frequencies of the wavelet scales.</span><span class="se">\</span>
<span class="s1">                          Increase the scale range.&#39;</span><span class="o">%</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">lowest_relevant_freq</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>

    <span class="n">lowest_frequency_row</span>  <span class="o">=</span>  <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">relevant_freqs</span><span class="p">)</span><span class="o">==</span><span class="n">freqs</span><span class="p">))</span>
    <span class="n">summed_profile</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">coefs</span><span class="p">[:</span><span class="n">lowest_frequency_row</span><span class="o">+</span><span class="mi">1</span><span class="p">,:]),</span> <span class="mi">0</span><span class="p">)</span>
    
    <span class="n">dbrms_profile</span> <span class="o">=</span> <span class="n">dB</span><span class="p">(</span><span class="n">moving_rms_edge_robust</span><span class="p">(</span><span class="n">summed_profile</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
    <span class="n">dbrms_profile</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">dbrms_profile</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">dbrms_profile</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">background_threshold</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">IncorrectThreshold</span><span class="p">(</span><span class="s1">&#39;The dynamic range of the signal is lower than the background threshold.</span><span class="se">\</span>
<span class="s1">        Please decrease the background threshold&#39;</span><span class="p">)</span>

    <span class="n">potential_region</span> <span class="o">=</span> <span class="n">identify_valid_regions</span><span class="p">(</span><span class="n">dbrms_profile</span><span class="o">&gt;=</span><span class="n">background_threshold</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">potential_region</span><span class="p">,</span> <span class="n">dbrms_profile</span></div>

<div class="viewcode-block" id="identify_valid_regions"><a class="viewcode-back" href="../../index.html#measure_horseshoe_bat_calls.segment_horseshoebat_call.identify_valid_regions">[docs]</a><span class="k">def</span> <span class="nf">identify_valid_regions</span><span class="p">(</span><span class="n">condition_satisfied</span><span class="p">,</span> <span class="n">num_expected_regions</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    condition_satisfied : np.array</span>
<span class="sd">        Boolean numpy array with samples either being True or False. </span>
<span class="sd">        The array may have multiple regions which satisfy a conditions (True)</span>
<span class="sd">        separated by smaller regions which don&#39;t (False).</span>
<span class="sd">    num_expected_regions : int &gt; 0 </span>
<span class="sd">        The number of expected regions which satisfy a condition. </span>
<span class="sd">        If &gt;2, then the first two longest continuous regions will be returned,</span>
<span class="sd">        and the smaller regions will be suppressed/eliminated.</span>
<span class="sd">        Defaults to 1. </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    valid_regions : np.array</span>
<span class="sd">        Boolean array which identifies the regions with the longest</span>
<span class="sd">        contiguous lengths.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">regions_of_interest</span><span class="p">,</span> <span class="n">all_region_data</span> <span class="o">=</span> <span class="n">identify_maximum_contiguous_regions</span><span class="p">(</span><span class="n">condition_satisfied</span><span class="p">,</span> <span class="n">num_expected_regions</span><span class="p">)</span>
    <span class="n">valid_samples</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="n">all_region_ids</span> <span class="o">=</span> <span class="n">all_region_data</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">each</span> <span class="ow">in</span> <span class="n">regions_of_interest</span><span class="p">:</span>
        <span class="n">valid_samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">all_region_data</span><span class="p">[</span><span class="n">all_region_ids</span><span class="o">==</span><span class="n">each</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">valid_samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">valid_samples</span><span class="p">)</span>
    
    <span class="n">valid_regions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">condition_satisfied</span><span class="o">.</span><span class="n">size</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;bool&#39;</span><span class="p">)</span>
    <span class="n">valid_regions</span><span class="p">[</span><span class="n">valid_samples</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
    
    <span class="k">return</span> <span class="n">valid_regions</span></div>

<div class="viewcode-block" id="identify_maximum_contiguous_regions"><a class="viewcode-back" href="../../index.html#measure_horseshoe_bat_calls.segment_horseshoebat_call.identify_maximum_contiguous_regions">[docs]</a><span class="k">def</span> <span class="nf">identify_maximum_contiguous_regions</span><span class="p">(</span><span class="n">condition_satisfied</span><span class="p">,</span> <span class="n">number_regions_of_interest</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Given a Boolean array - this function identifies regions of contiguous samples that</span>
<span class="sd">    are true and labels each with its own region_number. </span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    condition_satisfied : np.array</span>
<span class="sd">        Numpy array with Boolean (True/False) entries for each sample. </span>
<span class="sd">    number_regions_of_interest : integer &gt; 1</span>
<span class="sd">        Number of contiguous regions which are to be detected. The region ids </span>
<span class="sd">        are output in descending order (longest--&gt;shortest).</span>
<span class="sd">        Defaults to 1. </span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    region_numbers : list</span>
<span class="sd">        List with numeric IDs given to each contiguous region which is True.</span>
<span class="sd">    region_id_and_samples : np.array</span>
<span class="sd">        Two columns numpy array. Column 0 has the region_number, and Column 1 has </span>
<span class="sd">        the individual samples that belong to each region_number. </span>

<span class="sd">    Raises</span>
<span class="sd">    -------</span>
<span class="sd">    ValueError : This happens if the condition_satisfied array has no entries that are True. </span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">region_number</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">region_and_samples</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># identify the Trues, and assign the sample index to a region number</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">each</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">condition_satisfied</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">each</span><span class="p">:</span>
            <span class="n">region_and_samples</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">region_number</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">region_number</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="c1"># count number of samples in each region and output the top 1/2/... regions </span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">region_id_and_samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">region_and_samples</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">regions</span><span class="p">,</span> <span class="n">region_length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">region_id_and_samples</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">region_numbers</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number_regions_of_interest</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">region_length</span><span class="p">)</span>
                <span class="n">region_numbers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">regions</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
                <span class="n">remaining_region_lengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">region_length</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
                <span class="n">remaining_regions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">regions</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">remaining_region_lengths</span><span class="p">)</span>
                <span class="n">region_numbers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">remaining_regions</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
                <span class="n">remaining_region_lengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">remaining_region_lengths</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
                <span class="n">remaining_regions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">remaining_regions</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">region_numbers</span><span class="p">,</span> <span class="n">region_id_and_samples</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;No regions satisfying the condition found: all entries are False&#39;</span><span class="p">)</span> </div>


<div class="viewcode-block" id="pre_process_for_segmentation"><a class="viewcode-back" href="../../index.html#measure_horseshoe_bat_calls.segment_horseshoebat_call.pre_process_for_segmentation">[docs]</a><span class="k">def</span> <span class="nf">pre_process_for_segmentation</span><span class="p">(</span><span class="n">call</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Performs a series of steps on a raw cf call before passing it for temporal segmentation </span>
<span class="sd">    into cf and fm. </span>
<span class="sd">    Step 1: find peak frequency</span>
<span class="sd">    Step 2: lowpass (fm_audio) and highpass (cf_audio) below</span>
<span class="sd">            a fixed percentage of the peak frequency</span>
<span class="sd">    Step 3: calculate the moving dB  of the fm and cf audio</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    -----------</span>
<span class="sd">    call : np.array</span>
<span class="sd">    fs : int.</span>
<span class="sd">        Frequency of sampling in Hertz</span>
<span class="sd">    peak_percentage : 0&lt;float&lt;1, optional</span>
<span class="sd">        This is the fraction of the peak at which low and high-pass filtering happens.</span>
<span class="sd">        Defaults to 0.98.</span>
<span class="sd">    lowpass : optional</span>
<span class="sd">        Custom lowpass filtering coefficients. See low_and_highpass_around_threshold</span>
<span class="sd">    highpass : </span>
<span class="sd">        Custom highpass filtering coefficients. See low_and_highpass_around_threshold</span>
<span class="sd">    window_size : integer, optional</span>
<span class="sd">        The window size in samples over which the moving rms of the low+high passed signals will be calculated.</span>
<span class="sd">        For default value see documentation of moving_rms</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    cf_dbrms, fm_dbrms : np.arrays</span>
<span class="sd">        The dB rms profile of the high + low passed versions of the input audio.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">peak_percentage</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;peak_percentage&#39;</span><span class="p">,</span> <span class="mf">0.99</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">peak_percentage</span> <span class="o">&gt;=</span> <span class="mf">1.0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Peak percentage is </span><span class="si">%f</span><span class="s1">. It cannot be &gt;=1 &#39;</span><span class="o">%</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">peak_percentage</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
    <span class="n">make_sure_its_positive</span><span class="p">(</span><span class="n">peak_percentage</span><span class="p">,</span> <span class="n">variable</span><span class="o">=</span><span class="s1">&#39;peak percentage&#39;</span><span class="p">)</span>
    
    <span class="n">peak_frequency</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">get_peak_frequency</span><span class="p">(</span><span class="n">call</span><span class="p">,</span> <span class="n">fs</span><span class="p">)</span>
    
    <span class="n">fraction_of_nyquist</span> <span class="o">=</span> <span class="n">peak_frequency</span><span class="o">/</span><span class="p">(</span><span class="n">fs</span><span class="o">*</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="k">if</span>  <span class="n">fraction_of_nyquist</span> <span class="o">&gt;=</span> <span class="mf">0.75</span><span class="o">*</span><span class="p">(</span><span class="n">fs</span><span class="o">*</span><span class="mf">0.5</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;The peak frequency in the call is </span><span class="si">%f</span><span class="s1"> ... this might lead to erroneous output!&#39;</span><span class="o">%</span><span class="n">fraction_of_nyquist</span><span class="p">))</span>

    <span class="n">threshold_frequency</span> <span class="o">=</span> <span class="n">peak_frequency</span><span class="o">*</span><span class="n">peak_percentage</span>
    <span class="n">fm_dominant_audio</span><span class="p">,</span> <span class="n">cf_dominant_audio</span> <span class="o">=</span> <span class="n">low_and_highpass_around_threshold</span><span class="p">(</span><span class="n">call</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">threshold_frequency</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="n">fm_rms</span> <span class="o">=</span> <span class="n">moving_rms_edge_robust</span><span class="p">(</span><span class="n">fm_dominant_audio</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">cf_rms</span> <span class="o">=</span> <span class="n">moving_rms_edge_robust</span><span class="p">(</span><span class="n">cf_dominant_audio</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="n">fm_dbrms</span><span class="p">,</span> <span class="n">cf_dbrms</span> <span class="o">=</span> <span class="n">dB</span><span class="p">(</span><span class="n">fm_rms</span><span class="p">),</span> <span class="n">dB</span><span class="p">(</span><span class="n">cf_rms</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cf_dbrms</span><span class="p">,</span> <span class="n">fm_dbrms</span></div>

<div class="viewcode-block" id="low_and_highpass_around_threshold"><a class="viewcode-back" href="../../index.html#measure_horseshoe_bat_calls.segment_horseshoebat_call.low_and_highpass_around_threshold">[docs]</a><span class="k">def</span> <span class="nf">low_and_highpass_around_threshold</span><span class="p">(</span><span class="n">audio</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">threshold_frequency</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Make two version of an audio clip: the low pass and high pass versions.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    audio : np.array</span>
<span class="sd">    fs : float&gt;0</span>
<span class="sd">        Frequency of sampling in Hz</span>
<span class="sd">    threshold_frequency : float&gt;0</span>
<span class="sd">        The frequency at which the lowpass and highpass operations are </span>
<span class="sd">        be done. </span>
<span class="sd">    lowpass,highpass : ndarrays, optional</span>
<span class="sd">        The b &amp; a polynomials of an IIR filter which define the</span>
<span class="sd">        lowpass and highpass filters.</span>
<span class="sd">        Defaults to a second order elliptical filter with rp of 3dB</span>
<span class="sd">        and rs of 10 dB. See signal.ellip for more details of rp and</span>
<span class="sd">        rs.</span>
<span class="sd">    pad_duration : float&gt;0, optional</span>
<span class="sd">        Zero-padding duration in seconds before low+high pass filtering. </span>
<span class="sd">        Defaults to 0.1 seconds.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    lp_audio, hp_audio : np.arrays</span>
<span class="sd">        The low and high pass filtered versions of the input audio. </span>
<span class="sd">        </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">lowpass</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;lowpass&#39;</span><span class="p">,</span> <span class="n">signal</span><span class="o">.</span><span class="n">ellip</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span> <span class="n">threshold_frequency</span><span class="o">/</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">fs</span><span class="p">),</span> <span class="s1">&#39;lowpass&#39;</span><span class="p">))</span>
    <span class="n">highpass</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;highpass&#39;</span><span class="p">,</span> <span class="n">signal</span><span class="o">.</span><span class="n">ellip</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span> <span class="n">threshold_frequency</span><span class="o">/</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">fs</span><span class="p">),</span> <span class="s1">&#39;highpass&#39;</span><span class="p">))</span>
    <span class="n">pad_duration</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;pad_duration&#39;</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
    <span class="n">make_sure_its_positive</span><span class="p">(</span><span class="n">pad_duration</span><span class="p">,</span> <span class="n">variable</span><span class="o">=</span><span class="s1">&#39;pad_duration&#39;</span><span class="p">)</span>
    <span class="n">pad_length</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">pad_duration</span><span class="o">*</span><span class="n">fs</span><span class="p">)</span>
    
    
    <span class="n">audio_padded</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">audio</span><span class="p">,</span> <span class="p">[</span><span class="n">pad_length</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;constant&#39;</span><span class="p">,</span> <span class="n">constant_values</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>

    <span class="n">lp_audio_raw</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">filtfilt</span><span class="p">(</span><span class="n">lowpass</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">lowpass</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">audio_padded</span><span class="p">)</span>
    <span class="n">lp_audio</span> <span class="o">=</span> <span class="n">lp_audio_raw</span><span class="p">[</span><span class="n">pad_length</span><span class="p">:</span><span class="o">-</span><span class="n">pad_length</span><span class="p">]</span>
    
    <span class="n">hp_audio_raw</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">filtfilt</span><span class="p">(</span><span class="n">highpass</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">highpass</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">audio_padded</span><span class="p">)</span>
    <span class="n">hp_audio</span> <span class="o">=</span> <span class="n">hp_audio_raw</span><span class="p">[</span><span class="n">pad_length</span><span class="p">:</span><span class="o">-</span><span class="n">pad_length</span><span class="p">]</span>
    
    <span class="k">return</span> <span class="n">lp_audio</span><span class="p">,</span> <span class="n">hp_audio</span></div>

<div class="viewcode-block" id="get_thresholds_re_max"><a class="viewcode-back" href="../../index.html#measure_horseshoe_bat_calls.segment_horseshoebat_call.get_thresholds_re_max">[docs]</a><span class="k">def</span> <span class="nf">get_thresholds_re_max</span><span class="p">(</span><span class="n">cf_dbrms</span><span class="p">,</span> <span class="n">fm_dbrms</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">fm_threshold</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">cf_threshold</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">fm_db_re_max</span> <span class="o">=</span> <span class="n">fm_dbrms</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">fm_dbrms</span><span class="p">)</span>
    <span class="n">cf_db_re_max</span> <span class="o">=</span> <span class="n">cf_dbrms</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">cf_dbrms</span><span class="p">)</span>

    <span class="n">fm_cf_duration</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">fm_and_cf_thresholds</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">num_shared_fm_cf_samples</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">each_fm</span> <span class="ow">in</span> <span class="n">fm_threshold</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">each_cf</span> <span class="ow">in</span> <span class="n">cf_threshold</span><span class="p">:</span>
            <span class="n">fm_and_cf_thresholds</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">each_fm</span><span class="p">,</span> <span class="n">each_cf</span><span class="p">))</span>
            <span class="n">fm_samples</span> <span class="o">=</span> <span class="n">fm_db_re_max</span> <span class="o">&gt;=</span> <span class="n">each_fm</span>
            <span class="n">cf_samples</span> <span class="o">=</span> <span class="n">cf_db_re_max</span> <span class="o">&gt;=</span> <span class="n">each_cf</span>

            <span class="n">common_fmcf_samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">cf_samples</span><span class="p">,</span> <span class="n">fm_samples</span><span class="p">))</span>
            <span class="n">num_shared_fm_cf_samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">common_fmcf_samples</span><span class="p">)</span>

            <span class="n">cf_and_fm_samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">cf_samples</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">fm_samples</span><span class="p">)</span>
            <span class="n">fm_cf_duration</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cf_and_fm_samples</span><span class="p">)</span>

    <span class="c1"># choose the parameter region that will allow the best compromise between number of common fm_cf samples </span>
    <span class="c1"># and the longest fm_cf durations. </span>
    <span class="n">optimisation_metric</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">num_shared_fm_cf_samples</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cf_and_fm_samples</span><span class="p">)</span>
    <span class="n">best_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">optimisation_metric</span><span class="p">)</span>
    <span class="n">best_threshold</span> <span class="o">=</span> <span class="n">fm_and_cf_thresholds</span><span class="p">[</span><span class="n">best_index</span><span class="p">]</span>
    
    <span class="k">return</span> <span class="n">num_shared_fm_cf_samples</span><span class="p">,</span> <span class="n">optimisation_metric</span><span class="p">,</span> <span class="n">best_threshold</span></div>

<span class="k">def</span> <span class="nf">instantaneous_frequency_profile</span><span class="p">(</span><span class="n">audio</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">hil</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">hilbert</span><span class="p">(</span><span class="n">audio</span><span class="p">)</span>
    <span class="n">instantaneous_phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unwrap</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">hil</span><span class="p">))</span>
    <span class="n">instantaneous_frequency</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">instantaneous_phase</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span> <span class="o">*</span> <span class="n">fs</span>
    <span class="n">instant_frequency_resized</span> <span class="o">=</span> <span class="n">resize_by_adding_one_sample</span><span class="p">(</span><span class="n">instantaneous_frequency</span><span class="p">,</span> <span class="n">audio</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">instant_frequency_resized</span>


<span class="k">def</span> <span class="nf">resize_by_adding_one_sample</span><span class="p">(</span><span class="n">input_signal</span><span class="p">,</span> <span class="n">original_signal</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Resizes the input_signal to the same size as the original signal by repeating one</span>
<span class="sd">    sample value. The sample value can either the last or the first sample of the input_signal. </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">check_signal_sizes</span><span class="p">(</span><span class="n">input_signal</span><span class="p">,</span> <span class="n">original_signal</span><span class="p">)</span>
    
    <span class="n">repeat_start</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;repeat_start&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">repeat_start</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">input_signal</span><span class="p">[</span><span class="mi">0</span><span class="p">]]),</span> <span class="n">input_signal</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">input_signal</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">input_signal</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])))</span>


<span class="k">def</span> <span class="nf">check_signal_sizes</span><span class="p">(</span><span class="n">input_signal</span><span class="p">,</span> <span class="n">original_signal</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">input_signal</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nb">int</span><span class="p">(</span><span class="n">original_signal</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
        <span class="n">msg1</span> <span class="o">=</span> <span class="s1">&#39;The input signal&quot;s size </span><span class="si">%d</span><span class="s1">&#39;</span><span class="o">%</span><span class="nb">int</span><span class="p">(</span><span class="n">input_signal</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="n">msg2</span> <span class="o">=</span> <span class="s1">&#39; is greater or equal to the original signal&quot;s size: </span><span class="si">%d</span><span class="s1">&#39;</span><span class="o">%</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">original_signal</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg1</span><span class="o">+</span><span class="n">msg2</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">original_signal</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="o">-</span> <span class="nb">int</span><span class="p">(</span><span class="n">input_signal</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The original signal is &gt;= 2 samples longer than the input signal.&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">instantaneous_frequency_profile</span><span class="p">(</span><span class="n">audio</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">hil</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">hilbert</span><span class="p">(</span><span class="n">audio</span><span class="p">)</span>
    <span class="n">instantaneous_phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unwrap</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">hil</span><span class="p">))</span>
    <span class="n">instantaneous_frequency</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">instantaneous_phase</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span> <span class="o">*</span> <span class="n">fs</span>
    <span class="n">instant_frequency_resized</span> <span class="o">=</span> <span class="n">resize_by_adding_one_sample</span><span class="p">(</span><span class="n">instantaneous_frequency</span><span class="p">,</span> <span class="n">audio</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">instant_frequency_resized</span>



<div class="viewcode-block" id="calc_proper_kernel_size"><a class="viewcode-back" href="../../index.html#measure_horseshoe_bat_calls.segment_horseshoebat_call.calc_proper_kernel_size">[docs]</a><span class="k">def</span> <span class="nf">calc_proper_kernel_size</span><span class="p">(</span><span class="n">durn</span><span class="p">,</span> <span class="n">fs</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;scipy.signal.medfilt requires an odd number of samples as</span>
<span class="sd">    kernel_size. This function calculates the number of samples</span>
<span class="sd">    for a given duration which is odd and is close to the </span>
<span class="sd">    required duration. </span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    durn : float</span>
<span class="sd">        Duration in seconds. </span>
<span class="sd">    fs : float</span>
<span class="sd">        Sampling rate in Hz</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    samples : int</span>
<span class="sd">        Number of odd samples that is equal to or little </span>
<span class="sd">        less (by one sample) than the input duration. </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">samples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">durn</span><span class="o">*</span><span class="n">fs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">remainder</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">samples</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">samples</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">msg_part1</span> <span class="o">=</span> <span class="s1">&#39;The given kernel length of </span><span class="si">%3f</span><span class="s1"> seconds and sampling rate of&#39;</span><span class="o">%</span><span class="n">durn</span>
        <span class="n">msg_part2</span> <span class="o">=</span> <span class="s1">&#39; </span><span class="si">%f</span><span class="s1"> leads to a kernel of &lt; 3 samples length. Increase kernel length!&#39;</span><span class="o">%</span><span class="n">fs</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg_part1</span><span class="o">+</span><span class="n">msg_part2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">samples</span></div>

<div class="viewcode-block" id="resize_by_adding_one_sample"><a class="viewcode-back" href="../../index.html#measure_horseshoe_bat_calls.segment_horseshoebat_call.resize_by_adding_one_sample">[docs]</a><span class="k">def</span> <span class="nf">resize_by_adding_one_sample</span><span class="p">(</span><span class="n">input_signal</span><span class="p">,</span> <span class="n">original_signal</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Resizes the input_signal to the same size as the original signal by repeating one</span>
<span class="sd">    sample value. The sample value can either the last or the first sample of the input_signal. </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">check_signal_sizes</span><span class="p">(</span><span class="n">input_signal</span><span class="p">,</span> <span class="n">original_signal</span><span class="p">)</span>
    
    <span class="n">repeat_start</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;repeat_start&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">repeat_start</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">input_signal</span><span class="p">[</span><span class="mi">0</span><span class="p">]]),</span> <span class="n">input_signal</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">input_signal</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">input_signal</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])))</span></div>


<span class="k">def</span> <span class="nf">check_signal_sizes</span><span class="p">(</span><span class="n">input_signal</span><span class="p">,</span> <span class="n">original_signal</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">input_signal</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nb">int</span><span class="p">(</span><span class="n">original_signal</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
        <span class="n">msg1</span> <span class="o">=</span> <span class="s1">&#39;The input signal&quot;s size </span><span class="si">%d</span><span class="s1">&#39;</span><span class="o">%</span><span class="nb">int</span><span class="p">(</span><span class="n">input_signal</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="n">msg2</span> <span class="o">=</span> <span class="s1">&#39; is greater or equal to the original signal&quot;s size: </span><span class="si">%d</span><span class="s1">&#39;</span><span class="o">%</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">original_signal</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg1</span><span class="o">+</span><span class="n">msg2</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">original_signal</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="o">-</span> <span class="nb">int</span><span class="p">(</span><span class="n">input_signal</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The original signal is &gt;= 2 samples longer than the input signal.&#39;</span><span class="p">)</span>
    

<div class="viewcode-block" id="median_filter"><a class="viewcode-back" href="../../index.html#measure_horseshoe_bat_calls.segment_horseshoebat_call.median_filter">[docs]</a><span class="k">def</span> <span class="nf">median_filter</span><span class="p">(</span><span class="n">input_signal</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Median filters a signal according to a user-settable</span>
<span class="sd">    window size. </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    input_signal : np.array</span>
<span class="sd">    fs : float</span>
<span class="sd">        Sampling rate in Hz.</span>
<span class="sd">    medianfilter_size : float, optional</span>
<span class="sd">        The window size in seconds. Defaults to 0.001 seconds. </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    med_filtered : np.array</span>
<span class="sd">        Median filtered version of the input_signal. </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">window_duration</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;medianfilter_size&#39;</span><span class="p">,</span>
                              <span class="mf">0.001</span><span class="p">)</span>
    <span class="n">kernel_size</span> <span class="o">=</span> <span class="n">calc_proper_kernel_size</span><span class="p">(</span><span class="n">window_duration</span><span class="p">,</span> <span class="n">fs</span><span class="p">)</span>
    <span class="n">med_filtered</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">medfilt</span><span class="p">(</span><span class="n">input_signal</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">med_filtered</span></div>

<div class="viewcode-block" id="identify_cf_ish_regions"><a class="viewcode-back" href="../../index.html#measure_horseshoe_bat_calls.segment_horseshoebat_call.identify_cf_ish_regions">[docs]</a><span class="k">def</span> <span class="nf">identify_cf_ish_regions</span><span class="p">(</span><span class="n">frequency_profile</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Identifies CF regions by comparing the rate of frequency modulation </span>
<span class="sd">    across the signal. If the frequency modulation within a region of </span>
<span class="sd">    the signal is less than the limit then it is considered a CF region. </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    frequency_profile : np.array</span>
<span class="sd">        The instantaneous frequency of the signal over time in Hz. </span>
<span class="sd">    fm_limit : float, optional </span>
<span class="sd">        The maximum rate of frequency modulation in Hz/s. </span>
<span class="sd">        Defaults to 1000 Hz/s</span>
<span class="sd">    medianfilter_size : float, optional</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    cfish_regions : np.array</span>
<span class="sd">        Boolean array where True indicates a low FM rate region. </span>
<span class="sd">        The output may still need to be cleaned before final use. </span>
<span class="sd">    clean_fmrate_resized</span>
<span class="sd">    </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    If you&#39;re used to reading FM modulation rates in kHz/ms then just </span>
<span class="sd">    follow this relation to get the required modulation rate in Hz/s:</span>
<span class="sd">    </span>
<span class="sd">    X kHz/ms = (X Hz/s)* 10^-6 </span>
<span class="sd">    </span>
<span class="sd">    OR </span>
<span class="sd">    </span>
<span class="sd">    X Hz/s = (X kHz/ms) * 10^6</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    median_filter</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">max_modulation</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;fm_limit&#39;</span><span class="p">,</span> <span class="mi">10000</span><span class="p">)</span> <span class="c1"># Hz/sec</span>
    <span class="n">fm_rate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">frequency_profile</span><span class="p">)</span>
    
    <span class="c1">#convert from Hz/sec to Hz/msec</span>
    <span class="n">fm_rate_hz_sec</span> <span class="o">=</span> <span class="n">fm_rate</span><span class="o">/</span><span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="n">fs</span><span class="p">)</span>
    
    <span class="n">clean_fmrate</span> <span class="o">=</span> <span class="n">median_filter</span><span class="p">(</span><span class="n">fm_rate_hz_sec</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">clean_fmrate_resized</span> <span class="o">=</span> <span class="n">resize_by_adding_one_sample</span><span class="p">(</span><span class="n">clean_fmrate</span><span class="p">,</span> <span class="n">frequency_profile</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="n">cfish_regions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">clean_fmrate_resized</span><span class="p">)</span><span class="o">&lt;=</span> <span class="n">max_modulation</span>
    <span class="k">return</span> <span class="n">cfish_regions</span><span class="p">,</span> <span class="n">clean_fmrate_resized</span></div>

<div class="viewcode-block" id="segment_cf_regions"><a class="viewcode-back" href="../../index.html#measure_horseshoe_bat_calls.segment_horseshoebat_call.segment_cf_regions">[docs]</a><span class="k">def</span> <span class="nf">segment_cf_regions</span><span class="p">(</span><span class="n">audio</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">freq_profile_raw</span> <span class="o">=</span> <span class="n">instantaneous_frequency_profile</span><span class="p">(</span><span class="n">audio</span><span class="p">,</span><span class="n">fs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">freq_profile_clean</span> <span class="o">=</span> <span class="n">median_filter</span><span class="p">(</span><span class="n">freq_profile_raw</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">cf_region</span><span class="p">,</span> <span class="n">fmrate_hz_per_msec</span> <span class="o">=</span> <span class="n">identify_cf_ish_regions</span><span class="p">(</span><span class="n">freq_profile_clean</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cf_region</span><span class="p">,</span> <span class="n">fmrate_hz_per_msec</span></div>
    








<div class="viewcode-block" id="CFIdentificationError"><a class="viewcode-back" href="../../index.html#measure_horseshoe_bat_calls.segment_horseshoebat_call.CFIdentificationError">[docs]</a><span class="k">class</span> <span class="nc">CFIdentificationError</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">):</span>
    <span class="k">pass</span></div>

<div class="viewcode-block" id="IncorrectThreshold"><a class="viewcode-back" href="../../index.html#measure_horseshoe_bat_calls.segment_horseshoebat_call.IncorrectThreshold">[docs]</a><span class="k">class</span> <span class="nc">IncorrectThreshold</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">):</span>
    <span class="k">pass</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Thejasvi Beleyur

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>